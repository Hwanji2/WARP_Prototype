using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class DragManager : MonoBehaviour
{
    public Camera mainCamera;             // 카메라 참조 – 마우스 위치를 월드로 바꿔야 해서 필요함
    public GameObject zonePrefab;         // 드래그로 생성될 영역 프리팹 (반투명 박스)

    private Vector2 dragStartPos;         // 드래그 시작 위치 기억용
    private GameObject currentZone;       // 현재 그리고 있는 영역 (임시)
    private GameObject blueZoneObj;       // 첫 번째 영역 (타겟)
    private GameObject redZoneObj;        // 두 번째 영역 (소스)
    private Rect blueZone, redZone;       // 실제 Rect로 계산용
    private bool isDragging = false;      // 현재 드래그 중인지
    private int dragCount = 0;            // 0이면 첫 드래그, 1이면 두 번째 드래그
    private float lastZoneTime = -10f;    // 마지막 드래그 시간
    private float zoneCooldown = 1f;      // 쿨타임 – 너무 빨리 여러 번 그리지 못하게

    // 롤백용 데이터 – 나중에 되돌릴 오브젝트 저장 
	/*근데 이거 오버라 삭제하는게 좋을 듯함*/
    private class RewindData
    {
        public GameObject obj;
        public Vector3 startPosition;
    }
    private List<RewindData> rewindList = new List<RewindData>();//대충 리스트로 관리

    void Update()
    {
        // 드래그 시작 – 마우스 눌렀고, 쿨타임 지났으면
        if (Input.GetMouseButtonDown(0) && Time.time - lastZoneTime > zoneCooldown)
        {
            dragStartPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
            isDragging = true;

            currentZone = Instantiate(zonePrefab);  // 영역 박스 하나 생성
            var sr = currentZone.GetComponent<SpriteRenderer>();
            var color = dragCount == 0 ? new Color(0, 0.6f, 1, 0.4f) : new Color(1, 0.3f, 0.3f, 0.4f); //첫번째면 퍼렁이 두번째면 뻘겅이 생성하는거임
            sr.color = color;

            lastZoneTime = Time.time;
        }

        // 드래그 중 – 계속 박스 크기 조정
        if (Input.GetMouseButton(0) && isDragging) //마우스 누르거나 드래깅하는지 판단함
        {
            Vector2 currentMousePos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
            UpdateRectVisual(currentZone, dragStartPos, currentMousePos);
        }

        // 드래그 끝 – 박스 위치 확정
        if (Input.GetMouseButtonUp(0) && isDragging)
        {
            isDragging = false;
            Vector2 endPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
            Rect zone = GetRectFromPoints(dragStartPos, endPos);

            if (dragCount == 0)
            {
                // 첫 박스 (파랑): 복사 대상 위치
                blueZone = zone;
                blueZoneObj = currentZone;
                dragCount = 1;
                RecordRewindTargets(); // 되돌릴 목록 미리 저장
            }
            else if (dragCount == 1)
            {
                // 두 번째 박스 (빨강): 이동시킬 애들
                redZone = zone;
                redZoneObj = currentZone;
                RemoveSubZoneObjectsFromRewind(); // 중첩되면 롤백 대상에서 제외
                TryMoveObjects(); // 이동 시도
            }
        }
    }

    void LateUpdate()
    {
        // 박스 살짝 반짝이게 –  살아있는 느낌주고 싶었음
        if (currentZone != null)
        {
            var sr = currentZone.GetComponent<SpriteRenderer>();
            Color c = sr.color;
            c.a = 0.3f + Mathf.Sin(Time.time * 4f) * 0.1f;
            sr.color = c;
        }
    }

    // 박스 위치 및 사이즈 갱신
    void UpdateRectVisual(GameObject zoneObj, Vector2 start, Vector2 end)
    {
        Vector2 size = end - start;
        Vector2 center = start + size / 2f; //센터가 필요한 이유는 위치 땜에
        zoneObj.transform.position = center;
        zoneObj.transform.localScale = new Vector3(Mathf.Abs(size.x), Mathf.Abs(size.y), 1f);
    }

    // 두 점으로 Rect 만들기
    Rect GetRectFromPoints(Vector2 p1, Vector2 p2)
    {
        Vector2 min = Vector2.Min(p1, p2);
        Vector2 max = Vector2.Max(p1, p2);
        return new Rect(min, max - min);
    }

    // 파란 박스 외부에 있는 Draggable 애들 저장(이것도 롤백 관련이라 레거시임)
    void RecordRewindTargets()
    {
        rewindList.Clear();
        foreach (GameObject obj in GameObject.FindGameObjectsWithTag("Draggable"))
        {
            if (!IsInsideZone(obj.transform.position, blueZone))
            {
                rewindList.Add(new RewindData
                {
                    obj = obj,
                    startPosition = obj.transform.position
                });
            }
        }
    }

    // 빨간 박스 안에 있는 애들은 롤백 대상에서 제거 (이것도 레거시임)
    void RemoveSubZoneObjectsFromRewind()
    {
        Collider2D[] subHits = Physics2D.OverlapBoxAll(redZone.center, redZone.size, 0f);
        foreach (var col in subHits)
        {
            rewindList.RemoveAll(data => data.obj == col.gameObject);
        }
    }

    // 오브젝트 이동 
    void TryMoveObjects()
    {
        List<GameObject> toMove = new List<GameObject>();
        Collider2D[] hits = Physics2D.OverlapBoxAll(redZone.center, redZone.size, 0f);
        bool hasConflict = false;

        foreach (var col in hits)
        {
            if (col.CompareTag("Draggable"))
            {
                GameObject obj = col.gameObject;
                Vector2 offset = (Vector2)obj.transform.position - redZone.position;
                Vector2 newPosition = blueZone.position + offset;

                // 충돌 범위 계산
                Bounds objBounds = obj.GetComponent<Collider2D>().bounds;
                Vector2 objSize = objBounds.size;
                Rect movedRect = new Rect(newPosition - objSize / 2f, objSize);

                if (CheckConflictWithOthers(movedRect, obj))
                {
                    hasConflict = true;
                    break;
                }

                toMove.Add(obj);
            }
        }

        if (hasConflict)
        {
            // 겹침 → 실패 연출 & 롤백
            StartCoroutine(DestroyZoneWithEffect(redZoneObj, Color.red, false, false));
            StartCoroutine(DestroyZoneWithEffect(blueZoneObj, Color.blue, false, true));
        }
        else
        {
            // 겹침 없음 → 옮기기 실행
            foreach (var obj in toMove)
            {
                Vector2 offset = (Vector2)obj.transform.position - redZone.position;
                obj.transform.position = blueZone.position + offset;
            }

            // 외부에 있던 애들 되돌리기 (여기 레거시임)
            foreach (var data in rewindList)
            {
                StartCoroutine(RewindObject(data));
            }

            StartCoroutine(DestroyZoneWithEffect(redZoneObj, Color.red, true, false));
            StartCoroutine(DestroyZoneWithEffect(blueZoneObj, Color.blue, true, true));
        }
    }

    // 안에 들어갔는지 판별 (이거 중요함)
    bool IsInsideZone(Vector2 pos, Rect zone)
    {
        return zone.Contains(pos);
    }

    // 겹침 검사
    bool CheckConflictWithOthers(Rect targetRect, GameObject self)
    {
        Collider2D[] others = Physics2D.OverlapBoxAll(targetRect.center, targetRect.size, 0f);
        foreach (var col in others)
        {
            if (col.gameObject != self && col.CompareTag("Draggable"))
            {
                return true;
            }
        }
        return false;
    }

    // 롤백 연출 – 이동 애니메이션 (롤백 뺄거면 쓸데없음)
    IEnumerator RewindObject(RewindData data)
    {
        SpriteRenderer sr = data.obj.GetComponent<SpriteRenderer>();
        Collider2D col = data.obj.GetComponent<Collider2D>();

        if (col != null) col.enabled = false;
        if (sr != null)
        {
            Color c = sr.color;
            c.a = 0.4f;
            sr.color = c;
        }

        float duration = 0.5f;
        float t = 0f;
        Vector3 from = data.obj.transform.position;
        Vector3 to = data.startPosition;

        while (t < duration)
        {
            t += Time.deltaTime;
            data.obj.transform.position = Vector3.Lerp(from, to, t / duration);
            yield return null;
        }

        data.obj.transform.position = to;

        if (sr != null)
        {
            Color c = sr.color;
            c.a = 1f;
            sr.color = c;
        }

        if (col != null) col.enabled = true;
    }

    // 영역 박스 제거 애니메이션 – 실패는 흔들고 사라짐, 성공은 줄어들면서 사라짐
    IEnumerator DestroyZoneWithEffect(GameObject zone, Color color, bool merge, bool reset)
    {
        if (zone == null) yield break;

        var sr = zone.GetComponent<SpriteRenderer>();
        float t = 0f;
        float duration = 0.3f;
        Vector3 originalScale = zone.transform.localScale;

        while (t < duration)
        {
            t += Time.deltaTime;
            float progress = t / duration;

            if (merge)
            {
                // 부드럽게 사라짐
                zone.transform.localScale = Vector3.Lerp(originalScale, Vector3.zero, progress);
                sr.color = Color.Lerp(color, new Color(color.r, color.g, color.b, 0), progress);
            }
            else
            {
                // 흔들면서 사라짐
                float shake = Mathf.Sin(progress * 40f) * 0.1f;
                zone.transform.localScale = originalScale + new Vector3(shake, shake, 0);
                sr.color = Color.Lerp(color, new Color(color.r, color.g, color.b, 0), progress);
            }

            yield return null;
        }

        Destroy(zone);

        if (reset)
        {
            ResetDrag(); // 초기화
        }
    }

    // 모든 상태 초기화
    void ResetDrag()
    {
        dragCount = 0;
        blueZone = new Rect();
        redZone = new Rect();
        blueZoneObj = null;
        redZoneObj = null;
        rewindList.Clear();
    }
}
